# Next.js Connect Wallet

import { FileTree } from "nextra/components";

## Install

```zsh filename="Terminal"
yarn create next-app
yarn add --dev prettier prettier-plugin-tailwindcss
```

## Create .prettierrc

```json filename=".prettierrc"
{
  "plugins": ["prettier-plugin-tailwindcss"]
}
```

## File Tree

<FileTree>
  <FileTree.Folder name="src" defaultOpen>
    <FileTree.Folder name="app" defaultOpen>
      <FileTree.File name="layout.tsx" />
      <FileTree.File name="page.tsx" />
    </FileTree.Folder>
    <FileTree.Folder name="components" defaultOpen>
      <FileTree.File name="Display.tsx" />
      <FileTree.File name="MetaMaskError.tsx" />
      <FileTree.File name="Navigation.tsx" />
    </FileTree.Folder>
    <FileTree.Folder name="context" defaultOpen>
      <FileTree.File name="MetaMaskProvider.tsx" />
    </FileTree.Folder>
    <FileTree.Folder name="hooks" defaultOpen>
      <FileTree.File name="useMetaMask.tsx" />
    </FileTree.Folder>
    <FileTree.Folder name="utils" defaultOpen>
      <FileTree.File name="index.tsx" />
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

## layout.tsx

```tsx filename="layout.tsx"
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

import MetaMaskProvider from "../context/MetaMaskProvider";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <MetaMaskProvider>{children}</MetaMaskProvider>
      </body>
    </html>
  );
}
```

## page.tsx

```tsx filename="page.tsx"
import { Navigation } from "../components/Navigation";
import { Display } from "../components/Display";
import { MetaMaskError } from "../components/MetaMaskError";

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col space-y-10 p-24">
      <Navigation />
      <Display />
      <MetaMaskError />
    </main>
  );
}
```

## Utils

```ts filename="utils/index.tsx"
export const formatBalance = (rawBalance: string) => {
  const balance = (parseInt(rawBalance) / 1000000000000000000).toFixed(2);
  return balance;
};

export const formatChainAsNum = (chainIdHex: string) => {
  const chainIdNum = parseInt(chainIdHex);
  return chainIdNum;
};

export const formatAddress_ = (addr: string) => {
  return `${addr.substring(0, 8)}...`;
};

export const formatAddress = (addr: string) => {
  return `${addr.slice(0, 5)}...${addr.slice(addr.length - 4)}`;
};
```

## Display.tsx

```tsx filename="Display.tsx"
"use client";

import { useMetaMask } from "../hooks/useMetaMask";
import { formatChainAsNum } from "../utils";

export const Display = () => {
  const { wallet } = useMetaMask();

  return (
    <div>
      {wallet.accounts.length > 0 && (
        <>
          <div>Wallet Accounts: {wallet.accounts[0]}</div>
          <div>Wallet Balance: {wallet.balance}</div>
          <div>Hex ChainId: {wallet.chainId}</div>
          <div>Numeric ChainId: {formatChainAsNum(wallet.chainId)}</div>
        </>
      )}
    </div>
  );
};
```

## Navigation.tsx

```tsx filename="Navigation.tsx"
"use client";

import { useMetaMask } from "../hooks/useMetaMask";
import { formatAddress } from "../utils";

export const Navigation = () => {
  const { wallet, hasProvider, isMetaMask, isConnecting, connectMetaMask } =
    useMetaMask();

  return (
    <div>
      <div className="flex items-center justify-between">
        <h1 className="text-xl font-semibold">Fund Me Dapp</h1>
        <div>
          {!hasProvider && (
            <a href="https://metamask.io" target="_blank">
              Install MetaMask
            </a>
          )}
          {isMetaMask && wallet.accounts.length < 1 && (
            <button
              className="rounded-md bg-sky-500 px-6 py-3 hover:bg-sky-600"
              disabled={isConnecting}
              onClick={connectMetaMask}
            >
              Connect MetaMask
            </button>
          )}
          {hasProvider && wallet.accounts.length > 0 && (
            <a
              href={`https://sepolia.etherscan.io/address/${wallet.accounts[0]}`}
              target="_blank"
              data-tooltip="Open in Block Explorer"
              className=" px-6 py-3 text-sky-500 underline"
            >
              {formatAddress(wallet.accounts[0])} -&gt;
            </a>
          )}
        </div>
      </div>
    </div>
  );
};
```

## MetaMaskError.tsx

```tsx filename="MetaMaskError.tsx"
"use client";

import { useMetaMask } from "../hooks/useMetaMask";

export const MetaMaskError = () => {
  const { error, errorMessage, clearError } = useMetaMask();
  return (
    <div>
      {error && (
        <div onClick={clearError}>
          <strong>Error:</strong> {errorMessage}
        </div>
      )}
    </div>
  );
};
```

## MetaMaskProvider.tsx

```tsx filename="display/MetaMaskProvider.tsx"
"use client";

import { PropsWithChildren } from "react";
import { MetaMaskContextProvider } from "../hooks/useMetaMask";

export default function MetaMaskProvider({ children }: PropsWithChildren) {
  return <MetaMaskContextProvider>{children}</MetaMaskContextProvider>;
}
```

## useMetaMask.tsx

```tsx filename="useMetaMask.tsx"
"use client";

declare global {
  interface Window {
    ethereum: any;
  }
}

import {
  PropsWithChildren,
  createContext,
  useCallback,
  useContext,
  useEffect,
  useState,
} from "react";

import detectEthereumProvider from "@metamask/detect-provider";
import { formatBalance } from "../utils";

interface WalletState {
  accounts: any[];
  balance: string;
  chainId: string;
}

interface MetaMaskContextData {
  wallet: WalletState;
  hasProvider: boolean | null;
  isMetaMask: boolean;
  error: boolean;
  errorMessage: string;
  isConnecting: boolean;
  connectMetaMask: () => void;
  clearError: () => void;
}

const disconnectedState: WalletState = {
  accounts: [],
  balance: "",
  chainId: "",
};

const MetaMaskContext = createContext<MetaMaskContextData>(
  {} as MetaMaskContextData,
);

export const MetaMaskContextProvider = ({ children }: PropsWithChildren) => {
  const [hasProvider, setHasProvider] = useState<boolean | null>(null);
  const [isMetaMask, setIsMetaMask] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [wallet, setWallet] = useState(disconnectedState);
  const [errorMessage, setErrorMessage] = useState("");
  const clearError = () => setErrorMessage("");
  // useCallback ensures that you don't uselessly recreate the _updateWallet function on every render
  const _updateWallet = useCallback(async (providedAccounts?: any) => {
    const accounts =
      providedAccounts ||
      (await window.ethereum.request({ method: "eth_accounts" }));

    if (accounts.length === 0) {
      // If there are no accounts, then the user is disconnected
      setWallet(disconnectedState);
      return;
    }

    const balance = formatBalance(
      await window.ethereum.request({
        method: "eth_getBalance",
        params: [accounts[0], "latest"],
      }),
    );

    const chainId = await window.ethereum.request({
      method: "eth_chainId",
    });

    setWallet({ accounts, balance, chainId });
  }, []);

  const updateWalletAndAccounts = useCallback(
    () => _updateWallet(),
    [_updateWallet],
  );
  const updateWallet = useCallback(
    (accounts: any) => _updateWallet(accounts),
    [_updateWallet],
  );

  /**
   * This logic checks if MetaMask is installed. If it is, some event handlers are set up
   * to update the wallet state when MetaMask changes. The function returned by useEffect
   * is used as a "cleanup": it removes the event handlers whenever the MetaMaskProvider
   * is unmounted.
   */
  useEffect(() => {
    const getProvider = async () => {
      const provider = await detectEthereumProvider({ silent: true });
      setHasProvider(Boolean(provider));

      if (provider) {
        setIsMetaMask(window.ethereum.isMetaMask);
        updateWalletAndAccounts();
        window.ethereum.on("accountsChanged", updateWallet);
        window.ethereum.on("chainChanged", updateWalletAndAccounts);
      }
    };

    getProvider();

    return () => {
      window.ethereum?.removeListener("accountsChanged", updateWallet);
      window.ethereum?.removeListener("chainChanged", updateWalletAndAccounts);
    };
  }, [updateWallet, updateWalletAndAccounts]);

  const connectMetaMask = async () => {
    setIsConnecting(true);

    try {
      const accounts = await window.ethereum.request({
        method: "eth_requestAccounts",
      });
      clearError();
      updateWallet(accounts);
    } catch (err: any) {
      setErrorMessage(err.message);
    }
    setIsConnecting(false);
  };

  return (
    <MetaMaskContext.Provider
      value={{
        wallet,
        hasProvider,
        isMetaMask,
        error: !!errorMessage,
        errorMessage,
        isConnecting,
        connectMetaMask,
        clearError,
      }}
    >
      {children}
    </MetaMaskContext.Provider>
  );
};

export const useMetaMask = () => {
  const context = useContext(MetaMaskContext);
  if (context === undefined) {
    throw new Error(
      'useMetaMask must be used within a "MetaMaskContextProvider"',
    );
  }
  return context;
};
```
